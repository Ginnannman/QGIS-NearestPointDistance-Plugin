# -*- coding: utf-8 -*-

"""
/***************************************************************************
 NearestPointDistance
                                 A QGIS plugin
 This plugin exports Nearest Point & distance.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-02-14
        copyright            : (C) 2021 by Ginnannman
        email                : ginnannman at gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Ginnannman'
__date__ = '2021-02-14'
__copyright__ = '(C) 2021 by Ginnannman'

__revision__ = '$Format:%H$'

import os
import math

from qgis.PyQt.QtCore import (QCoreApplication,
                              QVariant)
from qgis.core import (QgsApplication,
                       QgsDistanceArea,
                       QgsFeature,
                       QgsFeatureRequest,
                       QgsFeatureSink,
                       QgsField,
                       QgsFields,
                       QgsGeometry,
                       QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterField,
                       QgsProcessingParameterNumber,
                       QgsProject,
                       QgsSpatialIndex,
                       QgsWkbTypes,
                       )


class NearestPointDistanceAlgorithm(QgsProcessingAlgorithm):
    

    INPUT = 'INPUT'
    INPUT_FIELD = 'INPUT_FIELD'
    TARGET = 'TARGET'
    TARGET_FIELD = 'TARGET_FIELD'
    OUTPUT = 'OUTPUT'


    def initAlgorithm(self, config=None):

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Input point layer'),
                [QgsProcessing.TypeVectorPoint]
            )
        )
        self.addParameter(
           QgsProcessingParameterField(
               self.INPUT_FIELD,
               self.tr('Input unique ID Field'),
              parentLayerParameterName = self.INPUT,
              type = QgsProcessingParameterField.Any
               )
          )
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.TARGET,
                self.tr('Target point layer'),
                [QgsProcessing.TypeVectorPoint]
                )
            )
        self.addParameter(
            QgsProcessingParameterField(
                self.TARGET_FIELD,
                self.tr('Target unique ID Field'),
               parentLayerParameterName = self.TARGET,
               type = QgsProcessingParameterField.Any
                )
            )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Nearest Points'),
                QgsProcessing.TypeVectorPoint
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        source = self.parameterAsSource(parameters, self.INPUT, context)
        if source is None:
           raise QgsProcessingException(self.invalidSourceError(parameters,self.INPUT))

        if QgsWkbTypes.isMultiType(source.wkbType()):
           raise QgsProcessingException(self.tr('Input point layer is a Multipoint layer -first convert to single points before using this algorithm.'))

        source_field = self.parameterAsString(parameters, self.INPUT_FIELD, context)
        target_source = self.parameterAsSource(parameters, self.TARGET, context)

        if target_source is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.TARGET))

        if QgsWkbTypes.isMultiType(target_source.wkbType()):
            raise QgsProcessingException(self.tr('Target point layer is a MultiPoint layer - first convert to single points before using this algorithm.'))

        if parameters[self.INPUT] == parameters[self.TARGET]:
            raise QgsProcessingException(self.tr('Input point layer and Target point layer are the same.'))

        target_field = self.parameterAsString(parameters, self.TARGET_FIELD, context)

     
        return self.NearestPointMatrix(parameters, context, source, source_field, target_source, target_field, feedback)

   
    def NearestPointMatrix(self, parameters, context, source, inField, target_source, targetField, feedback):


        inIdx = source.fields().lookupField(inField)
        outIdx = target_source.fields().lookupField(targetField)

        fields = QgsFields()
        input_id_field = source.fields()[inIdx]
        input_id_field.setName('InputID')
        fields.append(input_id_field)
        target_id_field = target_source.fields()[outIdx]
        target_id_field.setName('OutputID')
        fields.append(target_id_field)
        fields.append(QgsField('Distance', QVariant.Double))

        out_wkb = QgsWkbTypes.multiType(source.wkbType())
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context, fields, out_wkb, source.sourceCrs())

        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))
        index = QgsSpatialIndex(target_source.getFeatures(QgsFeatureRequest().setSubsetOfAttributes([]).setDestinationCrs(source.sourceCrs(), context.transformContext())), feedback)

        distArea = QgsDistanceArea()
        distArea.setSourceCrs(source.sourceCrs(), context.transformContext())
        distArea.setEllipsoid(context.project().ellipsoid())

        features = source.getFeatures(QgsFeatureRequest().setSubsetOfAttributes([inIdx]))
        total = 100.0 / source.featureCount() if source.featureCount() else 0
    
        for current, inFeat in enumerate(features):

            if feedback.isCanceled():
                break

            inGeom = inFeat.geometry()
            inID = str(inFeat[inIdx])
            featList = index.nearestNeighbor(inGeom.asPoint(),10)
            minDist = -100.0
            req = QgsFeatureRequest().setFilterFids(featList).setSubsetOfAttributes([outIdx]).setDestinationCrs(source.sourceCrs(), context.transformContext())
            for featCan in target_source.getFeatures(req):

                if feedback.isCanceled():
                    break
                canGeom = featCan.geometry()
                canDist = distArea.measureLine(inGeom.asPoint(),canGeom.asPoint())
                if minDist < 0 or canDist < minDist:
                    minDist = canDist
                    minFeat = featCan.id()

            request = QgsFeatureRequest().setFilterFid(minFeat).setSubsetOfAttributes([outIdx]).setDestinationCrs(source.sourceCrs(), context.transformContext())
           
            for outFeat in target_source.getFeatures(request):
                    outID = outFeat[outIdx]
                    outGeom = outFeat.geometry()
                    dist = distArea.measureLine(inGeom.asPoint(),outGeom.asPoint())
                    out_feature = QgsFeature()
                    out_geom = QgsGeometry.unaryUnion([inFeat.geometry(), outFeat.geometry()])
                    out_feature.setGeometry(out_geom)
                    out_feature.setAttributes([inID, outID, dist])
                    sink.addFeature(out_feature, QgsFeatureSink.FastInsert)

            feedback.setProgress(int(current * total))

        return {self.OUTPUT:dest_id}

    def name(self):
        return 'Nearest Point Distance'

    def displayName(self):
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'Nearest Point Distance'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return NearestPointDistanceAlgorithm()
